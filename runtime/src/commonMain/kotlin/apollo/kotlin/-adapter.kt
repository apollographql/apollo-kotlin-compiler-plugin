package apollo.kotlin

import kotlin.contracts.ExperimentalContracts
import kotlin.contracts.contract

interface Adapter<T> : Deserializer<T>, Serializer<T>

interface Deserializer<T> {
  fun fromJson(element: JsonElement): T
}

interface Serializer<T> {
  fun toJson(value: T): JsonElement
}

object StringAdapter : Adapter<String> {
  override fun fromJson(element: JsonElement): String {
    assertExpectedType<String>(element)
    return element
  }

  override fun toJson(value: String): JsonElement {
    return value
  }
}

object IntAdapter : Adapter<Int> {
  override fun fromJson(element: JsonElement): Int {
    assertExpectedType<Int>(element)
    return element
  }

  override fun toJson(value: Int): JsonElement {
    return value
  }
}

object BooleanAdapter : Adapter<Boolean> {
  override fun fromJson(element: JsonElement): Boolean {
    assertExpectedType<Boolean>(element)
    return element
  }

  override fun toJson(value: Boolean): JsonElement {
    return value
  }
}

object FloatAdapter : Adapter<Double> {
  override fun fromJson(element: JsonElement): Double {
    assertExpectedType<Double>(element)
    return element
  }

  override fun toJson(value: Double): JsonElement {
    return value
  }
}

class NullableAdapter<T : Any>(private val delegate: Adapter<T>) : Adapter<T?> {
  override fun fromJson(element: JsonElement): T? {
    if (element == null) {
      return null
    }
    return delegate.fromJson(element)
  }
  override fun toJson(value: T?): JsonElement {
    if (value == null) {
      return null
    }
    return delegate.toJson(value)
  }
}

class ListAdapter<T>(private val delegate: Adapter<T>) : Adapter<List<T>> {
  override fun fromJson(element: JsonElement): List<T> {
    assertExpectedType<List<*>>(element)

    return element.map {
      delegate.fromJson(it)
    }
  }
  override fun toJson(value: List<T>): JsonElement {
    return value.map { delegate.toJson(it) }
  }
}


@Deprecated("This is only to be used by the generated bytecode", level = DeprecationLevel.HIDDEN)
fun mergeField(container: MutableMap<String, JsonElement>, name: String, value: JsonElement) {
  mergeFieldInternal(container, name, value)
}

@Deprecated("This is only to be used by the generated bytecode", level = DeprecationLevel.HIDDEN)
fun mergeFragment(container: MutableMap<String, JsonElement>, fragment: JsonElement) {
  assertExpectedType<Map<*, *>>(fragment)

  fragment.entries.forEach {
    mergeFieldInternal(container, it.key as String, it.value)
  }
}

private fun mergeFieldInternal(container: MutableMap<String, JsonElement>, key: String, value: JsonElement) {
  if (!container.contains(key)) {
    container.put(key, value)
    return
  }
  container.put(key, container.get(key).mergeWith(value))
}


private fun Any?.mergeWith(other: Any?): Any? {
  if (this == null) {
    return other
  }
  if (other == null) {
    return this
  }
  return when (this) {
    is List<*> -> {
      check(other is List<*>) {
        "Cannot merge $this with $other"
      }
      check(size == other.size) {
        "Cannot merge $this with $other"
      }
      indices.map { i ->
        get(i).mergeWith(other.get(i))
      }
    }

    is Map<*, *> -> {
      check(other is Map<*, *>) {
        "Cannot merge $this with $other"
      }
      @Suppress("UNCHECKED_CAST")
      this as Map<String, Any?>
      @Suppress("UNCHECKED_CAST")
      other as Map<String, Any?>

      (keys + other.keys).associateWith {
        get(it).mergeWith(other.get(it))
      }
    }

    else -> {
      check(this == other) {
        error("Cannot merge $this with $other")
      }
      this
    }
  }
}

@OptIn(ExperimentalContracts::class)
inline fun <reified T> assertExpectedType(value: Any?) {
  contract {
    returns() implies (value is T)
  }
  if (value is Error) {
    throw GraphQLException(value)
  }
  if (value !is T) {
    throw IllegalStateException("Apollo: unexpected type '${value?.javaClass?.name}' (expected '${T::class.java.name}')")
  }
}

class GraphQLException(val error: Error) : Exception(error.message)